---
apiVersion: v1
kind: ConfigMap
metadata:
  name: lvm-monitor-scripts
  namespace: lvm-monitoring
data:
  monitor-lvm.sh: |
    #!/bin/bash
    set -euo pipefail

    # Configuration
    REPORT_FILE="/tmp/lvm-report-$(date +%Y%m%d-%H%M%S).json"
    CONTEXT="${KUBERNETES_CONTEXT:-$(kubectl config current-context)}"

    # Color codes for terminal output
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color

    echo -e "${BLUE}=== LVM Storage Report for ${CONTEXT} ===${NC}"
    echo "Generated at: $(date)"
    echo "Report file: ${REPORT_FILE}"
    echo

    # Initialize JSON report
    cat > "${REPORT_FILE}" <<EOF
    {
      "cluster": "${CONTEXT}",
      "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
      "nodes": [],
      "pvcs": [],
      "summary": {}
    }
    EOF

    # Function to get node LVM information
    get_node_lvm_info() {
        local node=$1
        echo -e "${GREEN}Checking node: ${node}${NC}"

        # Get node capacity and allocatable storage
        local node_info=$(kubectl get node "$node" -o json)
        local capacity=$(echo "$node_info" | jq -r '.status.capacity.storage // "unknown"')
        local allocatable=$(echo "$node_info" | jq -r '.status.allocatable.storage // "unknown"')
        local region=$(echo "$node_info" | jq -r '.metadata.labels["topology.kubernetes.io/region"] // "unknown"')

        # Get pods running on this node with LVM volumes
        local pods_with_lvm=$(kubectl get pods -A -o json | jq -r --arg node "$node" '
            .items[] |
            select(.spec.nodeName == $node) |
            select(.spec.volumes[]? | select(.persistentVolumeClaim != null)) |
            "\(.metadata.namespace)/\(.metadata.name)"
        ' | sort | uniq | wc -l)

        # Get total PVC capacity on this node
        local node_pvc_usage=$(kubectl get pv -o json | jq -r --arg node "$node" '
            .items[] |
            select(.spec.nodeAffinity.required.nodeSelectorTerms[].matchExpressions[]? |
                   select(.key == "kubernetes.io/hostname" and .values[] == $node)) |
            .spec.capacity.storage // "0"
        ' | awk '{
            gsub(/Gi/, "*1024*1024*1024");
            gsub(/Mi/, "*1024*1024");
            gsub(/Ki/, "*1024");
            s+=$1
        } END {
            if (s > 1099511627776) printf "%.2f Ti\n", s/1099511627776;
            else if (s > 1073741824) printf "%.2f Gi\n", s/1073741824;
            else if (s > 1048576) printf "%.2f Mi\n", s/1048576;
            else printf "%d bytes\n", s
        }')

        echo "  Region: ${region}"
        echo "  Capacity: ${capacity}"
        echo "  Allocatable: ${allocatable}"
        echo "  Pods with LVM volumes: ${pods_with_lvm}"
        echo "  Total PVC usage: ${node_pvc_usage:-0}"
        echo

        # Add to JSON report
        jq --arg node "$node" \
           --arg region "$region" \
           --arg capacity "$capacity" \
           --arg allocatable "$allocatable" \
           --arg pods "$pods_with_lvm" \
           --arg pvc_usage "${node_pvc_usage:-0}" \
           '.nodes += [{
               "name": $node,
               "region": $region,
               "capacity": $capacity,
               "allocatable": $allocatable,
               "pods_with_lvm": ($pods | tonumber),
               "total_pvc_usage": $pvc_usage
           }]' "${REPORT_FILE}" > "${REPORT_FILE}.tmp" && mv "${REPORT_FILE}.tmp" "${REPORT_FILE}"
    }

    # Get all nodes
    echo -e "${BLUE}=== Node Storage Status ===${NC}"
    for node in $(kubectl get nodes -o jsonpath='{.items[*].metadata.name}'); do
        get_node_lvm_info "$node"
    done

    # Analyze PVCs
    echo -e "${BLUE}=== PVC Analysis ===${NC}"

    # Get total allocated storage
    TOTAL_ALLOCATED=$(kubectl get pvc -A -o json | jq -r '
        .items[] |
        select(.status.phase=="Bound") |
        .spec.resources.requests.storage
    ' | awk '{
        gsub(/Gi/, "*1024*1024*1024");
        gsub(/Mi/, "*1024*1024");
        gsub(/Ki/, "*1024");
        s+=$1
    } END {
        print s
    }')

    TOTAL_ALLOCATED_HUMAN=$(echo "$TOTAL_ALLOCATED" | awk '{
        if ($1 > 1099511627776) printf "%.2f Ti\n", $1/1099511627776;
        else if ($1 > 1073741824) printf "%.2f Gi\n", $1/1073741824;
        else if ($1 > 1048576) printf "%.2f Mi\n", $1/1048576;
        else printf "%d bytes\n", $1
    }')

    echo "Total allocated storage: ${TOTAL_ALLOCATED_HUMAN}"

    # Count PVCs by namespace
    echo -e "\n${YELLOW}PVCs by namespace:${NC}"
    kubectl get pvc -A -o json | jq -r '
        .items[] |
        select(.status.phase=="Bound") |
        "\(.metadata.namespace) \(.spec.resources.requests.storage)"
    ' | awk '{
        ns[$1] += 1;
        gsub(/Gi/, "*1024*1024*1024", $2);
        gsub(/Mi/, "*1024*1024", $2);
        gsub(/Ki/, "*1024", $2);
        size[$1] += $2
    } END {
        for (n in ns) {
            if (size[n] > 1073741824)
                printf "%-20s %3d PVCs, %8.2f Gi\n", n, ns[n], size[n]/1073741824;
            else
                printf "%-20s %3d PVCs, %8.2f Mi\n", n, ns[n], size[n]/1048576;
        }
    }' | sort -k4 -nr

    # Find large PVCs
    echo -e "\n${YELLOW}Largest PVCs (>5Gi):${NC}"
    kubectl get pvc -A -o json | jq -r '
        .items[] |
        select(.status.phase=="Bound") |
        select(.spec.resources.requests.storage | test("[0-9]+Gi")) |
        select((.spec.resources.requests.storage | gsub("Gi";"") | tonumber) >= 5) |
        "\(.metadata.namespace)/\(.metadata.name) \(.spec.resources.requests.storage) \(.status.phase)"
    ' | sort -k2 -nr | head -20

    # Find orphaned PVCs (not mounted by any pod)
    echo -e "\n${YELLOW}Potentially orphaned PVCs:${NC}"

    # Get all PVCs
    kubectl get pvc -A -o json | jq -r '.items[] | "\(.metadata.namespace)/\(.metadata.name)"' | sort > /tmp/all-pvcs.txt

    # Get PVCs in use
    kubectl get pods -A -o json | jq -r '
        .items[].spec.volumes[]? |
        select(has("persistentVolumeClaim")) |
        .persistentVolumeClaim.claimName
    ' | sort | uniq > /tmp/used-pvcs.txt

    # Find the difference
    ORPHANED_COUNT=$(comm -23 /tmp/all-pvcs.txt /tmp/used-pvcs.txt | wc -l)
    if [ "$ORPHANED_COUNT" -gt 0 ]; then
        echo "Found ${ORPHANED_COUNT} potentially orphaned PVCs:"
        comm -23 /tmp/all-pvcs.txt /tmp/used-pvcs.txt | while read pvc; do
            ns=$(echo "$pvc" | cut -d/ -f1)
            name=$(echo "$pvc" | cut -d/ -f2)
            size=$(kubectl get pvc -n "$ns" "$name" -o jsonpath='{.spec.resources.requests.storage}')
            echo "  ${pvc} (${size})"
        done
    else
        echo "No orphaned PVCs found"
    fi

    # Check for failed PVC provisioning
    echo -e "\n${YELLOW}Failed or Pending PVCs:${NC}"
    FAILED_PVCS=$(kubectl get pvc -A | grep -v Bound | grep -v NAMESPACE | wc -l)
    if [ "$FAILED_PVCS" -gt 0 ]; then
        kubectl get pvc -A | grep -v Bound | grep -v NAMESPACE
    else
        echo "No failed or pending PVCs"
    fi

    # CNPG Database analysis
    echo -e "\n${BLUE}=== CNPG Database Storage ===${NC}"
    kubectl get cluster -A -o json 2>/dev/null | jq -r '
        .items[] |
        "\(.metadata.namespace)/\(.metadata.name) instances=\(.spec.instances) storage=\(.spec.storage.size) wal=\(.spec.walStorage.size // "default") status=\(.status.phase)"
    ' | column -t || echo "No CNPG clusters found"

    # Summary
    echo -e "\n${BLUE}=== Summary ===${NC}"
    echo "Total allocated storage: ${TOTAL_ALLOCATED_HUMAN}"
    echo "Orphaned PVCs: ${ORPHANED_COUNT}"
    echo "Failed/Pending PVCs: ${FAILED_PVCS}"

    # Add summary to JSON report
    jq --arg total "$TOTAL_ALLOCATED_HUMAN" \
       --arg orphaned "$ORPHANED_COUNT" \
       --arg failed "$FAILED_PVCS" \
       '.summary = {
           "total_allocated": $total,
           "orphaned_pvcs": ($orphaned | tonumber),
           "failed_pvcs": ($failed | tonumber)
       }' "${REPORT_FILE}" > "${REPORT_FILE}.tmp" && mv "${REPORT_FILE}.tmp" "${REPORT_FILE}"

    # Alert conditions
    echo -e "\n${BLUE}=== Alerts ===${NC}"
    ALERTS=0

    # Check if any node is using >80% of storage
    for node in $(kubectl get nodes -o jsonpath='{.items[*].metadata.name}'); do
        # This would require actual LVM checks on the node
        echo "Note: Direct LVM checks would require privileged DaemonSet access"
    done

    if [ "$ORPHANED_COUNT" -gt 5 ]; then
        echo -e "${RED}ALERT: High number of orphaned PVCs (${ORPHANED_COUNT})${NC}"
        ALERTS=$((ALERTS + 1))
    fi

    if [ "$FAILED_PVCS" -gt 0 ]; then
        echo -e "${RED}ALERT: Failed or pending PVCs detected (${FAILED_PVCS})${NC}"
        ALERTS=$((ALERTS + 1))
    fi

    if [ "$ALERTS" -eq 0 ]; then
        echo -e "${GREEN}No alerts - storage health looks good${NC}"
    fi

    # Save report
    echo -e "\n${GREEN}Report saved to: ${REPORT_FILE}${NC}"

    # Upload to MinIO if credentials are available
    if [ -n "$AWS_ACCESS_KEY_ID" ] && [ -n "$AWS_SECRET_ACCESS_KEY" ]; then
        echo -e "\n${BLUE}Uploading report to MinIO...${NC}"

        # Configure MinIO client
        mc alias set lvm-minio "$S3_ENDPOINT" "$AWS_ACCESS_KEY_ID" "$AWS_SECRET_ACCESS_KEY" --insecure 2>/dev/null

        # Generate report filename with timestamp
        REPORT_NAME="lvm-report-$(date +%Y%m%d-%H%M%S).json"
        HTML_NAME="lvm-report-$(date +%Y%m%d-%H%M%S).html"

        # Upload JSON report
        if mc cp "${REPORT_FILE}" "lvm-minio/${S3_BUCKET}/${S3_PREFIX}/${REPORT_NAME}" --insecure 2>/dev/null; then
            echo -e "${GREEN}JSON report uploaded successfully${NC}"
            REPORT_URL="https://infra.golder.lan/lvm-reports/${S3_PREFIX}/${REPORT_NAME}"

            # Generate and upload HTML report
            /opt/scripts/generate-html-report.sh
            if [ -f "/tmp/lvm-report-$(date +%Y%m%d).html" ]; then
                if mc cp "/tmp/lvm-report-$(date +%Y%m%d).html" "lvm-minio/${S3_BUCKET}/${S3_PREFIX}/${HTML_NAME}" --insecure 2>/dev/null; then
                    echo -e "${GREEN}HTML report uploaded successfully${NC}"
                    HTML_URL="https://infra.golder.lan/lvm-reports/${S3_PREFIX}/${HTML_NAME}"
                fi
            fi

            # Send Discord notification if webhook is configured
            if [ -n "$DISCORD_WEBHOOK_URL" ]; then
                echo -e "\n${BLUE}Sending Discord notification...${NC}"

                # Create Discord message with rich embed
                cat > /tmp/discord_payload.json << 'DISCORD_EOF'
                {
                  "embeds": [{
                    "title": "ðŸ“Š LVM Storage Report",
                    "description": "Storage monitoring report generated",
                    "color": 3447003,
                    "fields": [
                      {
                        "name": "ðŸ“ Total Allocated",
                        "value": "TOTAL_PLACEHOLDER",
                        "inline": true
                      },
                      {
                        "name": "ðŸ—‘ï¸ Orphaned PVCs",
                        "value": "ORPHANED_PLACEHOLDER",
                        "inline": true
                      },
                      {
                        "name": "âŒ Failed PVCs",
                        "value": "FAILED_PLACEHOLDER",
                        "inline": true
                      }
                    ],
                    "footer": {
                      "text": "CLUSTER_PLACEHOLDER â€¢ Click links below for full reports"
                    },
                    "timestamp": "TIMESTAMP_PLACEHOLDER"
                  }],
                  "content": "**ðŸ“ˆ Storage Report Available**\\n[ðŸ“‹ JSON Report](REPORT_URL_PLACEHOLDER)\\n[ðŸŒ HTML Report](HTML_URL_PLACEHOLDER)"
                }
                DISCORD_EOF

                # Replace placeholders with actual values
                sed -i "s/TOTAL_PLACEHOLDER/${TOTAL_ALLOCATED_HUMAN}/g" /tmp/discord_payload.json
                sed -i "s/ORPHANED_PLACEHOLDER/${ORPHANED_COUNT}/g" /tmp/discord_payload.json
                sed -i "s/FAILED_PLACEHOLDER/${FAILED_PVCS}/g" /tmp/discord_payload.json
                sed -i "s/CLUSTER_PLACEHOLDER/${CONTEXT}/g" /tmp/discord_payload.json
                sed -i "s|REPORT_URL_PLACEHOLDER|${REPORT_URL}|g" /tmp/discord_payload.json
                sed -i "s|HTML_URL_PLACEHOLDER|${HTML_URL:-$REPORT_URL}|g" /tmp/discord_payload.json
                sed -i "s/TIMESTAMP_PLACEHOLDER/$(date -u +%Y-%m-%dT%H:%M:%SZ)/g" /tmp/discord_payload.json

                if curl -H "Content-Type: application/json" -d @/tmp/discord_payload.json "$DISCORD_WEBHOOK_URL" 2>/dev/null; then
                    echo -e "${GREEN}Discord notification sent${NC}"
                else
                    echo -e "${YELLOW}Failed to send Discord notification${NC}"
                fi

                # Clean up
                rm -f /tmp/discord_payload.json
            fi
        else
            echo -e "${YELLOW}Failed to upload report to MinIO${NC}"
        fi
    fi

    # Clean up old reports (keep last 7 days)
    find /tmp -name "lvm-report-*.json" -mtime +7 -delete || true
    find /tmp -name "lvm-report-*.html" -mtime +7 -delete || true

  generate-html-report.sh: |
    #!/bin/bash
    # Generates an HTML report from the JSON data
    set -euo pipefail

    LATEST_REPORT=$(ls -t /tmp/lvm-report-*.json 2>/dev/null | head -1)
    if [ -z "$LATEST_REPORT" ]; then
        echo "No report found"
        exit 1
    fi

    HTML_REPORT="/tmp/lvm-report-$(date +%Y%m%d).html"

    cat > "$HTML_REPORT" <<'EOF'
    <!DOCTYPE html>
    <html>
    <head>
        <title>LVM Storage Report</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 20px; }
            h1, h2 { color: #333; }
            table { border-collapse: collapse; width: 100%; margin: 20px 0; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
            th { background-color: #4CAF50; color: white; }
            tr:nth-child(even) { background-color: #f2f2f2; }
            .alert { color: red; font-weight: bold; }
            .good { color: green; }
            .warning { color: orange; }
        </style>
    </head>
    <body>
        <h1>LVM Storage Report</h1>
    EOF

    # Add report content using jq to parse JSON
    jq -r '
        "<p>Generated: " + .timestamp + "</p>" +
        "<p>Cluster: " + .cluster + "</p>" +
        "<h2>Summary</h2>" +
        "<ul>" +
        "<li>Total Allocated: " + .summary.total_allocated + "</li>" +
        "<li>Orphaned PVCs: " + (.summary.orphaned_pvcs | tostring) + "</li>" +
        "<li>Failed PVCs: " + (.summary.failed_pvcs | tostring) + "</li>" +
        "</ul>" +
        "<h2>Node Storage Status</h2>" +
        "<table>" +
        "<tr><th>Node</th><th>Region</th><th>Capacity</th><th>Allocatable</th><th>Pods with LVM</th><th>PVC Usage</th></tr>" +
        (.nodes[] | "<tr><td>" + .name + "</td><td>" + .region + "</td><td>" + .capacity + "</td><td>" + .allocatable + "</td><td>" + (.pods_with_lvm | tostring) + "</td><td>" + .total_pvc_usage + "</td></tr>") +
        "</table>"
    ' "$LATEST_REPORT" >> "$HTML_REPORT"

    echo "</body></html>" >> "$HTML_REPORT"
    echo "HTML report generated: $HTML_REPORT"
